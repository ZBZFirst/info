<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Visualization Playground</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            width: 300px;
        }
        #data-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin: 5px 0;
        }
        input, select, button {
            width: 100%;
            margin: 5px 0;
            padding: 5px;
        }
        button {
            cursor: pointer;
        }
        .color-preview {
            width: 15px;
            height: 15px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #000;
        }
        .function-input {
            width: calc(100% - 10px);
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <div class="control-group">
            <h3>Axes Configuration</h3>
            <label>
                X-axis:
                <select id="x-axis-select">
                    <option value="rr">RR (Respiratory Rate)</option>
                    <option value="vt">VT (Tidal Volume)</option>
                    <option value="mv">MV (Minute Ventilation)</option>
                    <option value="custom">Custom Data</option>
                </select>
            </label>
            <label>
                Y-axis:
                <select id="y-axis-select">
                    <option value="mv">MV (Minute Ventilation)</option>
                    <option value="rr">RR (Respiratory Rate)</option>
                    <option value="vt">VT (Tidal Volume)</option>
                    <option value="custom">Custom Data</option>
                </select>
            </label>
            <label>
                Z-axis:
                <select id="z-axis-select">
                    <option value="none">None</option>
                    <option value="vt">VT (Tidal Volume)</option>
                    <option value="rr">RR (Respiratory Rate)</option>
                    <option value="mv">MV (Minute Ventilation)</option>
                    <option value="custom">Custom Data</option>
                </select>
            </label>
        </div>
        
        <div class="control-group">
            <h3>Visualization Settings</h3>
            <label>
                Point Size:
                <input type="range" id="point-size" min="1" max="20" value="5">
            </label>
            <label>
                Point Opacity:
                <input type="range" id="point-opacity" min="0.1" max="1" step="0.1" value="0.8">
            </label>
            <button id="reset-view">Reset View</button>
        </div>
    </div>
    
    <div id="data-panel">
        <div class="control-group">
            <h3>Data Configuration</h3>
            <label>
                Data Source:
                <select id="data-source">
                    <option value="generated">Generated Data</option>
                    <option value="equation">Equation</option>
                    <option value="upload">Upload CSV</option>
                </select>
            </label>
            
            <div id="generated-data-controls">
                <label>
                    VT Value:
                    <input type="range" id="vt-slider" min="0" max="20" value="0" step="1">
                    <span id="vt-value">0.00</span>
                </label>
                <label>
                    RR Range:
                    <input type="range" id="rr-range" min="0" max="40" value="40">
                </label>
            </div>
            
            <div id="equation-controls" style="display: none;">
                <label>
                    Equation (JavaScript):
                    <input type="text" id="equation-input" class="function-input" value="return x * y;">
                </label>
                <label>
                    X Range:
                    <input type="text" id="x-range" value="0,40,1">
                </label>
                <label>
                    Y Range:
                    <input type="text" id="y-range" value="0,1,0.05">
                </label>
                <button id="plot-equation">Plot Equation</button>
            </div>
            
            <div id="upload-controls" style="display: none;">
                <input type="file" id="csv-upload" accept=".csv">
                <label>
                    X Column:
                    <select id="x-column" disabled></select>
                </label>
                <label>
                    Y Column:
                    <select id="y-column" disabled></select>
                </label>
                <label>
                    Z Column:
                    <select id="z-column" disabled>
                        <option value="none">None</option>
                    </select>
                </label>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Color Mapping</h3>
            <label>
                Color By:
                <select id="color-by">
                    <option value="x">X-axis Value</option>
                    <option value="y">Y-axis Value</option>
                    <option value="z">Z-axis Value</option>
                    <option value="custom">Custom Function</option>
                </select>
            </label>
            
            <div id="color-function-controls" style="display: none;">
                <label>
                    Color Function (JavaScript):
                    <input type="text" id="color-function" class="function-input" value="return x > 20 ? 0xff0000 : 0x00ff00;">
                </label>
            </div>
            
            <div id="color-zones-controls">
                <h4>Color Zones</h4>
                <div id="color-zones-container">
                    <!-- Zones will be added here dynamically -->
                </div>
                <button id="add-zone">Add Color Zone</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script>
        // Three.js variables
        let scene, camera, renderer, controls;
        let points = [];
        let currentDataset = [];
        let colorZones = [];
        
        // Default configuration
        const defaultConfig = {
            axes: {
                x: { name: 'RR', min: 0, max: 40 },
                y: { name: 'MV', min: 0, max: 20 },
                z: { name: 'VT', min: 0, max: 1 }
            },
            visualization: {
                pointSize: 5,
                pointOpacity: 0.8
            },
            colorZones: [
                { max: 8, color: 0xff0000, label: 'Red Zone' },
                { max: 12, color: 0xffff00, label: 'Yellow Zone' },
                { max: 20, color: 0x00ff00, label: 'Green Zone' },
                { max: 30, color: 0xffff00, label: 'Yellow Zone' },
                { max: 40, color: 0xff0000, label: 'Red Zone' }
            ]
        };

        // Initialize the application
        init();

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(40, 40, 40);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;

            // Add grid and axes
            setupSceneHelpers();

            // Initialize UI
            setupUI();

            // Generate initial dataset
            generateDataset();
            updateVisualization();

            // Event listeners
            window.addEventListener('resize', onWindowResize);

            // Start animation loop
            animate();
        }

        function setupSceneHelpers() {
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(20);
            scene.add(axesHelper);

            // Add grid helper
            const gridHelper = new THREE.GridHelper(40, 40);
            scene.add(gridHelper);
        }

        function setupUI() {
            // Initialize color zones
            updateColorZonesUI();
            
            // Event listeners for controls
            document.getElementById('reset-view').addEventListener('click', resetView);
            document.getElementById('point-size').addEventListener('input', updateVisualizationSettings);
            document.getElementById('point-opacity').addEventListener('input', updateVisualizationSettings);
            document.getElementById('vt-slider').addEventListener('input', updateVTSlider);
            document.getElementById('rr-range').addEventListener('input', generateDataset);
            document.getElementById('add-zone').addEventListener('click', addColorZone);
            document.getElementById('data-source').addEventListener('change', toggleDataSourceControls);
            document.getElementById('color-by').addEventListener('change', toggleColorFunctionControls);
            document.getElementById('plot-equation').addEventListener('click', plotEquation);
            document.getElementById('csv-upload').addEventListener('change', handleFileUpload);
            
            // Initialize visualization settings
            updateVisualizationSettings();
        }

        function generateDataset() {
            const dataSource = document.getElementById('data-source').value;
            
            if (dataSource === 'generated') {
                generateRRVTData();
            } else if (dataSource === 'equation') {
                // Handled separately by plotEquation()
            } else if (dataSource === 'upload') {
                // Handled by handleFileUpload()
            }
        }

        function generateRRVTData() {
            currentDataset = [];
            const vtValue = parseInt(document.getElementById('vt-slider').value) * 0.05;
            const rrMax = parseInt(document.getElementById('rr-range').value);
            
            for (let rr = 0; rr <= rrMax; rr++) {
                const mv = rr * vtValue;
                
                currentDataset.push({
                    x: rr,
                    y: mv,
                    z: vtValue,
                    rr: rr,
                    vt: vtValue,
                    mv: mv
                });
            }
            
            updateVisualization();
        }

        function plotEquation() {
            try {
                const equationText = document.getElementById('equation-input').value;
                const equation = new Function('x', 'y', 'z', equationText);
                
                const xRange = document.getElementById('x-range').value.split(',').map(Number);
                const yRange = document.getElementById('y-range').value.split(',').map(Number);
                
                currentDataset = [];
                
                for (let x = xRange[0]; x <= xRange[1]; x += xRange[2] || 1) {
                    for (let y = yRange[0]; y <= yRange[1]; y += yRange[2] || 0.1) {
                        const z = equation(x, y, 0) || 0;
                        
                        currentDataset.push({
                            x: x,
                            y: y,
                            z: z,
                            custom: z
                        });
                    }
                }
                
                updateVisualization();
            } catch (error) {
                alert(`Error in equation: ${error.message}`);
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            Papa.parse(file, {
                header: true,
                complete: function(results) {
                    const data = results.data;
                    if (data.length === 0) return;
                    
                    // Update column selectors
                    const columns = Object.keys(data[0]);
                    const xSelect = document.getElementById('x-column');
                    const ySelect = document.getElementById('y-column');
                    const zSelect = document.getElementById('z-column');
                    
                    xSelect.innerHTML = '';
                    ySelect.innerHTML = '';
                    zSelect.innerHTML = '<option value="none">None</option>';
                    
                    columns.forEach(col => {
                        xSelect.appendChild(new Option(col, col));
                        ySelect.appendChild(new Option(col, col));
                        zSelect.appendChild(new Option(col, col));
                    });
                    
                    xSelect.disabled = false;
                    ySelect.disabled = false;
                    zSelect.disabled = false;
                    
                    // Store the raw data
                    currentDataset = data;
                    updateVisualization();
                }
            });
        }

        function updateVisualization() {
            // Clear existing points
            points.forEach(point => scene.remove(point));
            points = [];
            
            if (currentDataset.length === 0) return;
            
            // Get axis mappings
            const xAxis = document.getElementById('x-axis-select').value;
            const yAxis = document.getElementById('y-axis-select').value;
            const zAxis = document.getElementById('z-axis-select').value;
            
            // Prepare geometry
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            
            const pointSize = parseInt(document.getElementById('point-size').value);
            const pointOpacity = parseFloat(document.getElementById('point-opacity').value);
            
            // Process each data point
            currentDataset.forEach(data => {
                // Get coordinates based on axis selection
                const x = data[xAxis] || 0;
                const y = data[yAxis] || 0;
                const z = (zAxis !== 'none' && data[zAxis]) ? data[zAxis] : 0;
                
                positions.push(x, y, z);
                
                // Determine color
                const color = getColorForPoint(data);
                colors.push(
                    (color >> 16 & 255) / 255,
                    (color >> 8 & 255) / 255,
                    (color & 255) / 255
                );
                
                sizes.push(pointSize);
            });
            
            // Set geometry attributes
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            // Create points material
            const material = new THREE.PointsMaterial({
                size: pointSize,
                vertexColors: true,
                transparent: true,
                opacity: pointOpacity
            });
            
            // Add points to scene
            const pointsMesh = new THREE.Points(geometry, material);
            scene.add(pointsMesh);
            points.push(pointsMesh);
            
            // Update axes labels
            updateAxesLabels();
        }

        function getColorForPoint(data) {
            const colorBy = document.getElementById('color-by').value;
            
            if (colorBy === 'custom') {
                try {
                    const colorFunction = document.getElementById('color-function').value;
                    const func = new Function('x', 'y', 'z', 'data', colorFunction);
                    return func(data.x, data.y, data.z, data) || 0x888888;
                } catch {
                    return 0x888888;
                }
            }
            
            const value = colorBy === 'x' ? data.x : 
                          colorBy === 'y' ? data.y : 
                          colorBy === 'z' ? data.z : 0;
            
            for (const zone of colorZones) {
                if (value <= zone.max) {
                    return zone.color;
                }
            }
            
            return 0x888888; // Default gray
        }

        function updateAxesLabels() {
            // Clear existing labels
            points.forEach(point => {
                if (point.userData.isLabel) {
                    scene.remove(point);
                }
            });
            
            // Get axis names
            const xAxis = document.getElementById('x-axis-select').value;
            const yAxis = document.getElementById('y-axis-select').value;
            const zAxis = document.getElementById('z-axis-select').value;
            
            // Add new labels
            addLabel(-5, 0, 0, xAxis.toUpperCase(), 0xff0000);
            addLabel(0, -5, 0, yAxis.toUpperCase(), 0x00ff00);
            
            if (zAxis !== 'none') {
                addLabel(0, 0, -5, zAxis.toUpperCase(), 0x0000ff);
            }
        }

        function addLabel(x, y, z, text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.font = 'Bold 24px Arial';
            context.fillStyle = `rgb(${color >> 16}, ${color >> 8 & 255}, ${color & 255})`;
            context.textAlign = 'center';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(5, 2.5, 1);
            sprite.userData.isLabel = true;
            scene.add(sprite);
            points.push(sprite);
        }

        function updateColorZonesUI() {
            const container = document.getElementById('color-zones-container');
            container.innerHTML = '';
            
            colorZones = [...defaultConfig.colorZones];
            
            colorZones.forEach((zone, index) => {
                const zoneDiv = document.createElement('div');
                zoneDiv.className = 'color-zone';
                
                zoneDiv.innerHTML = `
                    <label>
                        Max Value:
                        <input type="number" class="zone-max" value="${zone.max}" step="0.1">
                    </label>
                    <label>
                        Color:
                        <input type="color" class="zone-color" value="#${zone.color.toString(16).padStart(6, '0')}">
                        <span class="color-preview" style="background-color: #${zone.color.toString(16).padStart(6, '0')}"></span>
                    </label>
                    <label>
                        Label:
                        <input type="text" class="zone-label" value="${zone.label}">
                    </label>
                    <button class="remove-zone" data-index="${index}">Remove</button>
                `;
                
                container.appendChild(zoneDiv);
            });
            
            // Add event listeners to the new elements
            document.querySelectorAll('.zone-max').forEach(input => {
                input.addEventListener('change', updateZoneFromUI);
            });
            
            document.querySelectorAll('.zone-color').forEach(input => {
                input.addEventListener('change', updateZoneFromUI);
            });
            
            document.querySelectorAll('.zone-label').forEach(input => {
                input.addEventListener('input', updateZoneFromUI);
            });
            
            document.querySelectorAll('.remove-zone').forEach(button => {
                button.addEventListener('click', removeColorZone);
            });
        }

        function updateZoneFromUI(event) {
            const index = event.target.closest('.color-zone').querySelector('.remove-zone').dataset.index;
            const zoneDiv = event.target.closest('.color-zone');
            
            colorZones[index] = {
                max: parseFloat(zoneDiv.querySelector('.zone-max').value),
                color: parseInt(zoneDiv.querySelector('.zone-color').value.substring(1), 16),
                label: zoneDiv.querySelector('.zone-label').value
            };
            
            // Update the color preview
            zoneDiv.querySelector('.color-preview').style.backgroundColor = 
                zoneDiv.querySelector('.zone-color').value;
            
            updateVisualization();
        }

        function addColorZone() {
            const newMax = colorZones.length > 0 ? 
                colorZones[colorZones.length - 1].max + 5 : 10;
            
            colorZones.push({
                max: newMax,
                color: 0x888888,
                label: 'New Zone'
            });
            
            updateColorZonesUI();
        }

        function removeColorZone(event) {
            const index = parseInt(event.target.dataset.index);
            colorZones.splice(index, 1);
            updateColorZonesUI();
            updateVisualization();
        }

        function toggleDataSourceControls() {
            const source = document.getElementById('data-source').value;
            
            document.getElementById('generated-data-controls').style.display = 
                source === 'generated' ? 'block' : 'none';
            document.getElementById('equation-controls').style.display = 
                source === 'equation' ? 'block' : 'none';
            document.getElementById('upload-controls').style.display = 
                source === 'upload' ? 'block' : 'none';
            
            if (source === 'generated') {
                generateRRVTData();
            } else if (source === 'equation') {
                plotEquation();
            }
        }

        function toggleColorFunctionControls() {
            const colorBy = document.getElementById('color-by').value;
            document.getElementById('color-function-controls').style.display = 
                colorBy === 'custom' ? 'block' : 'none';
            document.getElementById('color-zones-controls').style.display = 
                colorBy !== 'custom' ? 'block' : 'none';
            
            updateVisualization();
        }

        function updateVTSlider() {
            const vtValue = parseInt(document.getElementById('vt-slider').value) * 0.05;
            document.getElementById('vt-value').textContent = vtValue.toFixed(2);
            generateDataset();
        }

        function updateVisualizationSettings() {
            updateVisualization();
        }

        function resetView() {
            controls.reset();
            camera.position.set(40, 40, 40);
            camera.lookAt(0, 0, 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
