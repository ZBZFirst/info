<div id="graph3d" class="graph-3d"></div>

<script type="module">
console.log("Script started loading"); // Track script execution

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';
console.log("THREE imported successfully:", THREE); // Verify THREE import

import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/controls/OrbitControls.js';
console.log("OrbitControls imported successfully"); // Verify OrbitControls import

class DataVisualizer {
  constructor(containerId, data) {
    console.log("Creating DataVisualizer instance"); // Track instantiation
    this.container = document.getElementById(containerId);
    console.log("Container element:", this.container); // Verify container exists
    
    if (!this.container) {
      throw new Error(`Container element with ID ${containerId} not found`);
    }
    
    this.data = data;
    console.log("Data received:", data); // Verify data
    this.init();
  }

  init() {
    // Scene setup
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0xf0f0f0);
    
    // Camera setup
    this.camera = new THREE.PerspectiveCamera(
      75, 
      this.container.clientWidth / this.container.clientHeight, 
      0.1, 
      1000
    );
    this.camera.position.set(30, 30, 30);
    
    // Renderer setup
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.container.appendChild(this.renderer.domElement);

    // Create visualization
    this.createVisualization();
    
    // Add controls
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    
    // Handle resize
    window.addEventListener('resize', () => this.onWindowResize());
    
    // Start animation loop
    this.animate();
  }

  createVisualization() {
    // Find data ranges for normalization
    const yValues = this.data.map(d => d.y);
    const yMin = Math.min(...yValues);
    const yMax = Math.max(...yValues);

    // Create geometry
    const positions = new Float32Array(this.data.length * 3);
    const colors = new Float32Array(this.data.length * 3);
    
    this.data.forEach((point, i) => {
      // Positions
      positions[i*3] = point.x;
      positions[i*3+1] = point.y;
      positions[i*3+2] = point.z;
      
      // Color mapping (blue to red)
      const normalizedY = (point.y - yMin) / (yMax - yMin);
      const hue = 0.6 * (1 - normalizedY); // 0.6 = blue to red
      const color = new THREE.Color().setHSL(hue, 0.9, 0.5);
      colors[i*3] = color.r;
      colors[i*3+1] = color.g;
      colors[i*3+2] = color.b;
    });

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Create point cloud
    const material = new THREE.PointsMaterial({
      size: 0.2,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true
    });

    this.pointCloud = new THREE.Points(geometry, material);
    this.scene.add(this.pointCloud);

    // Add coordinate axes
    const axesHelper = new THREE.AxesHelper(20);
    this.scene.add(axesHelper);
  }

  onWindowResize() {
    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }
}

// Export for use in other modules
window.DataVisualizer = DataVisualizer;
console.log("DataVisualizer class exposed to window"); // Verify global exposure
</script>
